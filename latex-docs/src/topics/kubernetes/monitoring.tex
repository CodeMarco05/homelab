\subsection{K3s Monitoring Stack mit SSL-Konfiguration}

Dieser Abschnitt dokumentiert die vollständige Implementierung eines Monitoring-Stacks bestehend aus Prometheus, Grafana und AlertManager mit automatischen SSL-Zertifikaten von Let's Encrypt für K3s-Cluster.

\subsubsection{Systemvoraussetzungen und Architektur-Übersicht}

\paragraph{Technische Voraussetzungen}

\begin{itemize}
  \item Funktionsfähiger K3s Cluster mit Master- und Worker-Nodes
  \item Domain mit DNS-Konfiguration auf Server-IP (DNS-only, nicht proxied)
  \item Firewall-Freigaben für Ports 80, 443 und 6443
  \item Helm Package Manager Installation
\end{itemize}

\paragraph{Monitoring-Stack Komponenten}

Das implementierte System umfasst folgende Kernkomponenten:

\begin{itemize}
  \item \textbf{Prometheus} - Metriken-Sammlung und -Speicherung mit 15-Tage-Retention
  \item \textbf{Grafana} - Dashboard-Visualisierung mit SSL-optimierter Konfiguration
  \item \textbf{AlertManager} - Benachrichtigungs- und Alerting-System
  \item \textbf{Node Exporter} - Hardware- und OS-Metriken-Erfassung
  \item \textbf{cert-manager} - Automatische SSL-Zertifikat-Verwaltung
  \item \textbf{Let's Encrypt} - Kostenlose SSL-Zertifikate mit 60-Tage-Auto-Renewal
\end{itemize}

\subsubsection{Helm und Repository-Konfiguration}

\paragraph{Helm Installation und Verifikation}

\begin{verbatim}
# Helm Installation
curl https://raw.githubusercontent.com/helm/helm/main/\
  scripts/get-helm-3 | bash

# Installation verifizieren
helm version
\end{verbatim}

\paragraph{Prometheus Community Repository}

\begin{verbatim}
# Repository hinzufügen
helm repo add prometheus-community \
  https://prometheus-community.github.io/helm-charts

# Repository aktualisieren
helm repo update

# Verfügbare Charts verifizieren
helm search repo prometheus-community/kube-prometheus-stack
\end{verbatim}

\paragraph{Monitoring Namespace erstellen}

\begin{verbatim}
# Dediziertes Namespace für Monitoring-Komponenten
kubectl create namespace monitoring

# Namespace verifizieren
kubectl get namespaces
\end{verbatim}

\subsubsection{DNS-Konfiguration und SSL-Vorbereitung}

\paragraph{DNS-Konfiguration}

Die Domain-Konfiguration muss als \textbf{DNS-only} (nicht proxied) erfolgen:

\begin{itemize}
  \item \textbf{Domain:} \texttt{grafana.k8s.marco-brandt.com}
  \item \textbf{Type:} A Record
  \item \textbf{Content:} Server Public IP (z.B. \texttt{<PUBLIC\_IP>})
  \item \textbf{Proxy Status:} DNS only (graue Wolke in Cloudflare)
\end{itemize}

\paragraph{DNS-Verifikation}

\begin{verbatim}
nslookup grafana.k8s.marco-brandt.com
# Sollte Server-IP zurückgeben, nicht Cloudflare-IPs
\end{verbatim}

\subsubsection{Grafana Ingress mit SSL-Terminierung}

\paragraph{SSL-optimierte Ingress-Konfiguration}

\begin{verbatim}
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: grafana-ingress
  namespace: monitoring
  annotations:
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    traefik.ingress.kubernetes.io/redirect-to-https: "true"
    traefik.ingress.kubernetes.io/custom-response-headers: |
      X-Frame-Options: SAMEORIGIN
      X-Content-Type-Options: nosniff
      X-XSS-Protection: 1; mode=block
      Referrer-Policy: strict-origin-when-cross-origin
      Strict-Transport-Security: max-age=31536000; includeSubDomains
spec:
  ingressClassName: traefik
  tls:
  - hosts:
    - grafana.k8s.marco-brandt.com
    secretName: grafana-letsencrypt-cert
  rules:
  - host: grafana.k8s.marco-brandt.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: prometheus-grafana
            port:
              number: 80
\end{verbatim}

\subsubsection{Monitoring Stack Helm Values}

\paragraph{Grafana SSL-optimierte Konfiguration}

\begin{verbatim}
grafana:
  adminPassword: "admin123"
  grafana.ini:
    server:
      domain: grafana.k8s.marco-brandt.com
      root_url: https://grafana.k8s.marco-brandt.com
      serve_from_sub_path: false
      protocol: http
      http_port: 3000
      cookie_secure: true
    security:
      allow_embedding: false
      strict_transport_security: true
      strict_transport_security_max_age_seconds: 31536000
      strict_transport_security_preload: true
      strict_transport_security_subdomains: true
      content_type_protection: true
      x_content_type_options: nosniff
      x_xss_protection: true
  service:
    type: ClusterIP
    port: 80
    targetPort: 3000
  resources:
    requests:
      memory: 256Mi
      cpu: 250m
    limits:
      memory: 512Mi
      cpu: 500m
  persistence:
    enabled: true
    size: 10Gi
  tolerations:
  - key: node-role.kubernetes.io/control-plane
    operator: Exists
    effect: NoSchedule
\end{verbatim}

\paragraph{Prometheus Persistenz und Ressourcen-Konfiguration}

\begin{verbatim}
prometheus:
  prometheusSpec:
    retention: 15d
    storageSpec:
      volumeClaimTemplate:
        spec:
          accessModes: ["ReadWriteOnce"]
          resources:
            requests:
              storage: 20Gi
    resources:
      requests:
        memory: 512Mi
        cpu: 500m
      limits:
        memory: 2Gi
        cpu: 1000m
    tolerations:
    - key: node-role.kubernetes.io/control-plane
      operator: Exists
      effect: NoSchedule
\end{verbatim}

\paragraph{AlertManager Persistenz-Konfiguration}

\begin{verbatim}
alertmanager:
  alertmanagerSpec:
    storage:
      volumeClaimTemplate:
        spec:
          accessModes: ["ReadWriteOnce"]
          resources:
            requests:
              storage: 5Gi
    resources:
      requests:
        memory: 128Mi
        cpu: 100m
      limits:
        memory: 256Mi
        cpu: 200m
    tolerations:
    - key: node-role.kubernetes.io/control-plane
      operator: Exists
      effect: NoSchedule
\end{verbatim}

\subsubsection{Deployment und Zertifikat-Monitoring}

\paragraph{Monitoring Stack Deployment}

\begin{verbatim}
# ClusterIssuer anwenden
kubectl apply -f letsencrypt-issuer.yaml

# Monitoring Stack installieren
helm install prometheus \
  prometheus-community/kube-prometheus-stack \
  -namespace monitoring \
  -values monitoring-values.yaml \
  -wait

# Grafana Ingress mit SSL erstellen
kubectl apply -f grafana-ingress.yaml
\end{verbatim}

\paragraph{SSL-Zertifikat Status-Überwachung}

\begin{verbatim}
# Zertifikat-Status live überwachen
kubectl get certificate -n monitoring -w

# Detaillierte Zertifikat-Information
kubectl describe certificate \
  grafana-letsencrypt-cert -n monitoring

# ACME Challenge Status überprüfen
kubectl get challenges -A

# cert-manager Logs analysieren
kubectl logs -n cert-manager \
  deployment/cert-manager -tail=20
\end{verbatim}

\paragraph{Zertifikat-Gültigkeit Validierung}

\begin{verbatim}
# HTTPS-Verbindung testen
curl -I https://grafana.k8s.marco-brandt.com

# Zertifikat-Ablaufdatum überprüfen
kubectl get secret grafana-letsencrypt-cert \
  -n monitoring \
  -o jsonpath='{.data.tls\.crt}' | \
  base64 -d | \
  openssl x509 -noout -dates
\end{verbatim}

\subsubsection{Service-Zugriff und Verifikation}

\paragraph{Grafana Web-Interface}

Nach erfolgreicher Zertifikat-Ausstellung:

\begin{itemize}
  \item \textbf{URL:} \texttt{https://grafana.k8s.marco-brandt.com}
  \item \textbf{Benutzername:} \texttt{admin}
  \item \textbf{Passwort:} \texttt{admin123}
\end{itemize}

\paragraph{Prometheus Web-Interface (Port-Forward)}

\begin{verbatim}
# Prometheus UI über Port-Forward zugänglich machen
kubectl port-forward -n monitoring \
  svc/prometheus-kube-prometheus-prometheus \
  9090:9090

# Zugriff über: http://localhost:9090
\end{verbatim}

\paragraph{AlertManager Web-Interface (Port-Forward)}

\begin{verbatim}
# AlertManager UI über Port-Forward zugänglich machen
kubectl port-forward -n monitoring \
  svc/prometheus-kube-prometheus-alertmanager \
  9093:9093

# Zugriff über: http://localhost:9093
\end{verbatim}

\subsubsection{Dashboard-Konfiguration und Metriken}

\paragraph{Wichtige vorkonfigurierte Dashboards}

Der Monitoring Stack umfasst folgende essenzielle Dashboards:

\begin{itemize}
  \item \textbf{Kubernetes / Compute Resources / Cluster} - Cluster-Gesamt-Metriken
  \item \textbf{Kubernetes / Compute Resources / Node (Pods)} - Pro-Node Pod-Metriken
  \item \textbf{Kubernetes / Compute Resources / Pod} - Individuelle Pod-Metriken
  \item \textbf{Node Exporter / Nodes} - Detaillierte Hardware-Metriken
  \item \textbf{Kubernetes / API Server} - Kubernetes API Performance
  \item \textbf{Prometheus / Overview} - Prometheus interne Metriken
\end{itemize}

\paragraph{OpenLens Integration}

Prometheus-Integration in OpenLens:

\begin{verbatim}
# OpenLens Einstellungen -> Metrics
# Prometheus Endpoint:
http://prometheus-kube-prometheus-prometheus.\
monitoring.svc.cluster.local:9090
\end{verbatim}

\subsubsection{Wartung und Troubleshooting}

\paragraph{Automatische Zertifikat-Erneuerung}

\begin{itemize}
  \item \textbf{Intervall:} Automatische Erneuerung alle 60 Tage
  \item \textbf{Wartung:} Keine manuelle Intervention erforderlich
  \item \textbf{Monitoring:} Kontinuierliche Überwachung des Zertifikat-Status empfohlen
\end{itemize}

\paragraph{Monitoring Stack Updates}

\begin{verbatim}
# Helm Repository aktualisieren
helm repo update

# Monitoring Stack upgraden
helm upgrade prometheus \
  prometheus-community/kube-prometheus-stack \
  -namespace monitoring \
  -values monitoring-values.yaml
\end{verbatim}

\paragraph{Häufige Troubleshooting-Szenarien}

\textbf{Zertifikat-Ausstellung fehlgeschlagen:}

\begin{verbatim}
# ACME Challenge Logs überprüfen
kubectl describe challenges -A

# Traefik Logs analysieren
kubectl logs -n kube-system \
  deployment/traefik -tail=20

# DNS-Auflösung validieren
nslookup grafana.k8s.marco-brandt.com
\end{verbatim}

\textbf{Verbindungsprobleme:}

\begin{verbatim}
# Firewall-Status überprüfen
sudo ufw status

# Erforderliche Ports freigeben
sudo ufw allow 80
sudo ufw allow 443

# Traefik Service-Status
kubectl get pods -n kube-system | grep traefik
\end{verbatim}

\paragraph{Backup und Persistenz}

\begin{verbatim}
# Grafana-Konfiguration Backup
kubectl get configmaps -n monitoring | grep grafana

# Prometheus Daten-Persistenz Verifikation
kubectl get pvc -n monitoring
\end{verbatim}

Die implementierte Monitoring-Lösung bietet eine professionelle, produktionsreife Observability-Infrastruktur mit automatisierter SSL-Verwaltung und gewährleistet langfristige Wartbarkeit des K3s Homelab-Clusters.